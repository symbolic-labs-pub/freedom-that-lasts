name: CI

# Fun fact: GitHub Actions was launched in 2019, making CI/CD accessible to millions of developers!
on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC - because maintenance never sleeps!
  workflow_dispatch:  # Manual trigger for the control enthusiasts

# Cancel in-progress runs for same branch to prevent badge update races
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write  # For gh-pages deployment
  pull-requests: write  # For PR comments

jobs:
  test:
    name: Test Suite
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f  # v3.12.0

      - name: Build test Docker image
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83  # v6.18.0 (upgraded from v5 for security)
        with:
          context: .
          file: ./Dockerfile.test
          tags: ftl-test:latest
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create output directories
        run: |
          mkdir -p coverage test-results
          # Set permissions for Docker container user (UID 1001)
          chmod 777 coverage test-results

      - name: Run tests with coverage
        continue-on-error: true  # Continue even if tests fail
        run: |
          docker run --rm \
            -v ${{ github.workspace }}/coverage:/app/coverage \
            -v ${{ github.workspace }}/test-results:/app/test-results \
            ftl-test:latest

      - name: Extract coverage percentage
        if: always()  # Always extract coverage even if tests failed
        id: coverage
        run: |
          COVERAGE=$(python3 -c "import json; data=json.load(open('coverage/coverage.json')); print(f\"{data['totals']['percent_covered']:.2f}\")")
          echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT
          echo "Coverage: $COVERAGE%"

          # Determine badge color based on coverage thresholds
          if (( $(echo "$COVERAGE >= 90" | bc -l) )); then
            COLOR="brightgreen"
          elif (( $(echo "$COVERAGE >= 75" | bc -l) )); then
            COLOR="green"
          elif (( $(echo "$COVERAGE >= 60" | bc -l) )); then
            COLOR="yellow"
          else
            COLOR="red"
          fi
          echo "color=$COLOR" >> $GITHUB_OUTPUT
          echo "Badge color: $COLOR"

      - name: Upload coverage reports
        if: always()  # Always upload coverage even if tests failed
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.2
        with:
          name: coverage-reports
          path: |
            coverage/coverage.xml
            coverage/coverage.json
            coverage/htmlcov/
          retention-days: 30

      - name: Upload test results
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.2
        if: always()
        with:
          name: test-results
          path: test-results/junit.xml
          retention-days: 30

      - name: Extract test metadata
        if: always()  # Run even if tests fail
        id: test-metadata
        run: |
          python3 << 'EOF'
          import xml.etree.ElementTree as ET
          import os

          # Parse junit.xml to determine test status
          try:
              tree = ET.parse('test-results/junit.xml')
              root = tree.getroot()
              failures = int(root.attrib.get('failures', 0))
              errors = int(root.attrib.get('errors', 0))
              test_status = 'pass' if (failures == 0 and errors == 0) else 'fail'
          except:
              test_status = 'fail'

          # Write test status to GITHUB_OUTPUT
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"test_status={test_status}\n")

          print(f"Test status: {test_status}")
          EOF

          # Extract commit and date info
          echo "commit_sha=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT
          echo "test_date=$(date -u +%Y-%m-%d)" >> $GITHUB_OUTPUT
          echo "run_url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_OUTPUT

      - name: Extract SQLite version
        if: always()
        id: sqlite-version
        run: |
          SQLITE_VERSION=$(python3 -c "import sqlite3; print(sqlite3.sqlite_version)")
          echo "version=$SQLITE_VERSION" >> $GITHUB_OUTPUT
          echo "SQLite version: $SQLITE_VERSION"

      - name: Upload coverage JSON for badge
        if: always()  # Always upload for badge generation
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4.6.2
        with:
          name: coverage-json
          path: coverage/coverage.json
          retention-days: 1  # Only needed for badge generation

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b  # v7.1.0
        with:
          script: |
            const coverage = '${{ steps.coverage.outputs.percentage }}';
            const color = '${{ steps.coverage.outputs.color }}';
            const body = `## Test Coverage Report\n\n**Coverage**: ${coverage}% (${color})\n\n_Coverage data from latest test run._`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

    outputs:
      coverage: ${{ steps.coverage.outputs.percentage }}
      badge_color: ${{ steps.coverage.outputs.color }}
      test_status: ${{ steps.test-metadata.outputs.test_status }}
      commit_sha: ${{ steps.test-metadata.outputs.commit_sha }}
      test_date: ${{ steps.test-metadata.outputs.test_date }}
      run_url: ${{ steps.test-metadata.outputs.run_url }}
      sqlite_version: ${{ steps.sqlite-version.outputs.version }}

  generate-badges:
    name: Generate Coverage Badge
    needs: test
    runs-on: ubuntu-latest
    if: always() && github.ref == 'refs/heads/master'  # Always run on master, even if tests fail

    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
        with:
          ref: master

      - name: Download coverage JSON
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4.3.0
        with:
          name: coverage-json

      - name: Generate SVG badge
        run: |
          # Pure Python SVG generation - no external dependencies!
          # Fun fact: SVG has been a web standard since 2001, predating most modern web frameworks
          python3 << 'EOF'
          import json
          import os

          # Load coverage data
          with open('coverage.json') as f:
              data = json.load(f)

          coverage = data['totals']['percent_covered']
          coverage_str = f"{coverage:.0f}%"

          # Determine color
          if coverage >= 90:
              color = '#4c1'  # brightgreen
          elif coverage >= 75:
              color = '#97ca00'  # green
          elif coverage >= 60:
              color = '#dfb317'  # yellow
          else:
              color = '#e05d44'  # red

          # Generate shields.io-compatible SVG badge
          # Width calculation: "coverage" (54) + percentage width (54) = 108px
          svg = f'''<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="108" height="20" role="img" aria-label="coverage: {coverage_str}">
            <title>coverage: {coverage_str}</title>
            <linearGradient id="s" x2="0" y2="100%">
              <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
              <stop offset="1" stop-opacity=".1"/>
            </linearGradient>
            <clipPath id="r">
              <rect width="108" height="20" rx="3" fill="#fff"/>
            </clipPath>
            <g clip-path="url(#r)">
              <rect width="61" height="20" fill="#555"/>
              <rect x="61" width="47" height="20" fill="{color}"/>
              <rect width="108" height="20" fill="url(#s)"/>
            </g>
            <g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110">
              <text aria-hidden="true" x="315" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="510">coverage</text>
              <text x="315" y="140" transform="scale(.1)" fill="#fff" textLength="510">coverage</text>
              <text aria-hidden="true" x="835" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="{len(coverage_str)*90}">{coverage_str}</text>
              <text x="835" y="140" transform="scale(.1)" fill="#fff" textLength="{len(coverage_str)*90}">{coverage_str}</text>
            </g>
          </svg>'''

          # Create badges directory and write SVG
          os.makedirs('badges', exist_ok=True)
          with open('badges/coverage.svg', 'w') as f:
              f.write(svg)

          print(f"Generated coverage badge: {coverage_str} ({color})")
          EOF

      - name: Generate test status badges
        run: |
          python3 << 'EOF'
          import os

          test_status = "${{ needs.test.outputs.test_status }}"
          commit_sha = "${{ needs.test.outputs.commit_sha }}"
          test_date = "${{ needs.test.outputs.test_date }}"
          run_url = "${{ needs.test.outputs.run_url }}"
          commit_url = "${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}"

          def generate_badge_svg(label, value, color, link_url):
              label_width = len(label) * 7 + 10
              value_width = len(value) * 7 + 10
              total_width = label_width + value_width

              return f'''<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{total_width}" height="20" role="img">
              <a target="_blank" xlink:href="{link_url}">
                  <linearGradient id="s" x2="0" y2="100%">
                      <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
                      <stop offset="1" stop-opacity=".1"/>
                  </linearGradient>
                  <clipPath id="r">
                      <rect width="{total_width}" height="20" rx="3" fill="#fff"/>
                  </clipPath>
                  <g clip-path="url(#r)">
                      <rect width="{label_width}" height="20" fill="#555"/>
                      <rect x="{label_width}" width="{value_width}" height="20" fill="{color}"/>
                      <rect width="{total_width}" height="20" fill="url(#s)"/>
                  </g>
                  <g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" text-rendering="geometricPrecision" font-size="110">
                      <text aria-hidden="true" x="{label_width/2*10}" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="{(label_width-10)*10}">{label}</text>
                      <text x="{label_width/2*10}" y="140" transform="scale(.1)" fill="#fff" textLength="{(label_width-10)*10}">{label}</text>
                      <text aria-hidden="true" x="{(label_width + value_width/2)*10}" y="150" fill="#010101" fill-opacity=".3" transform="scale(.1)" textLength="{(value_width-10)*10}">{value}</text>
                      <text x="{(label_width + value_width/2)*10}" y="140" transform="scale(.1)" fill="#fff" textLength="{(value_width-10)*10}">{value}</text>
                  </g>
              </a>
          </svg>'''

          os.makedirs("badges", exist_ok=True)

          # ALWAYS update badge 3 (last run) - shows current status
          run_color = "#4c1" if test_status == "pass" else "#e05d44"
          with open("badges/test-run.svg", "w") as f:
              f.write(generate_badge_svg("last run", test_date, run_color, run_url))

          # ONLY update badges 1 & 2 if tests pass (preserve on failure)
          if test_status == "pass":
              with open("badges/test-date.svg", "w") as f:
                  f.write(generate_badge_svg("tests pass", test_date, "#4c1", commit_url))

              with open("badges/test-commit.svg", "w") as f:
                  f.write(generate_badge_svg("commit", commit_sha, "#4c1", commit_url))

              print(f"Updated all badges: pass, {test_date}, {commit_sha}")
          else:
              print(f"Updated last-run badge only: fail, {test_date} (preserved pass badges)")

          # Generate SQLite version badge (always blue, informational)
          sqlite_version = "${{ needs.test.outputs.sqlite_version }}"
          with open("badges/sqlite.svg", "w") as f:
              f.write(generate_badge_svg("sqlite", sqlite_version, "#007ec6", "https://www.sqlite.org"))

          print(f"Generated SQLite badge: {sqlite_version}")

          # Generate License badge (green if valid, red if invalid)
          # Fun fact: Apache License 2.0 is one of the most permissive open source licenses!
          import os.path

          license_valid = False
          license_file = "LICENCE.txt"
          required_string = "http://www.apache.org/licenses/LICENSE-2.0"

          # Check if LICENCE.txt exists and contains the required string
          if os.path.isfile(license_file):
              with open(license_file, 'r', encoding='utf-8') as f:
                  license_content = f.read()
                  if required_string in license_content:
                      license_valid = True

          # Set badge color: green if valid, red if invalid
          license_color = "#4c1" if license_valid else "#e05d44"
          license_status = "Apache 2.0" if license_valid else "invalid"

          with open("badges/license.svg", "w") as f:
              f.write(generate_badge_svg("license", license_status, license_color, "https://opensource.org/licenses/Apache-2.0"))

          print(f"Generated License badge: {license_status} ({'valid' if license_valid else 'invalid'})")
          EOF

      - name: Commit and push badges to master
        run: |
          git config user.name 'github-actions[bot]'
          git config user.email 'github-actions[bot]@users.noreply.github.com'
          git add badges/coverage.svg badges/test-date.svg badges/test-commit.svg badges/test-run.svg badges/sqlite.svg badges/license.svg
          git diff --quiet && git diff --staged --quiet || git commit -m "Update badges (coverage + test status + sqlite + license) [skip ci]"
          git push

  summary:
    name: Workflow Summary
    needs: [test]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Generate summary
        run: |
          echo "## Test Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Coverage**: ${{ needs.test.outputs.coverage }}%" >> $GITHUB_STEP_SUMMARY
          echo "**Badge Color**: ${{ needs.test.outputs.badge_color }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.ref }}" == "refs/heads/master" ]; then
            echo "Badges updated on master branch" >> $GITHUB_STEP_SUMMARY
          else
            echo "_Badges not updated (not master branch)_" >> $GITHUB_STEP_SUMMARY
          fi
